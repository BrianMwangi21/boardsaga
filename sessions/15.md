### Session 15 - Phase 6 Planning: Stockfish Integration

**Date**: December 30, 2025

**Summary**:
- Identified LLM hallucination issue in story generation (wrong move numbers and moves)
- Added Phase 6 to ROADMAP.md for Stockfish chess engine integration
- Clarified requirements: key positions, async processing, caching, evaluation scores, fallback
- Decided on client-side stockfish.js approach (simpler, no job queue)
- Planned standalone testing with sample games before integration

**Problem Identified**:
The LLM is hallucinating moves in generated stories:
- Chapter 2 references move 5 as "Nf3" - but actual move 5 was "Bc4"
- Chapter 3 references move 9 as "Qxf7#" (checkmate) - but actual move 9 was "Bb3", game just ended with "1-0"

The `fixChessBoardsInStory()` function only fixes FEN, not move numbers or SAN notation.

**Clarification Questions & Answers**:

1. **Analysis depth target**: Key positions only (not every move)
2. **Real-time vs async**: Async processing preferred
3. **Caching strategy**: Yes, cache engine analysis by PGN hash
4. **Evaluation granularity**: Full evaluation scores for LLM detail
5. **Fallback behavior**: Fallback to LLM initially, show errors after confident testing

**Stockfish Integration Options Evaluated**:

1. **Client-Side stockfish.js (CHOSEN)**:
   - Load in browser via WebAssembly
   - Pros: Free server resources, no API costs, simpler architecture
   - Cons: Mobile slower, bundle size, device dependent
   - Acceptable tradeoffs given requirements

2. Server-Side (npm package): Vercel 10s timeout limitation
3. External REST API: Cost, privacy concerns
4. Hybrid: Complex for current use case

**Phase 6 Architecture Decision**:

**Client-Side Stockfish + Server Processing**:
```
User uploads PGN
    ↓
PGN parsed
    ↓
stockfish.js runs in browser (WebAssembly)
    ↓
Engine analyzes key positions (5-15s)
    ↓
Engine data sent to server with PGN hash
    ↓
Server checks cache by PGN hash
    ↓
If not cached, cache engine data
    ↓
LLM generates story with engine data
    ↓
Story saved to DB
```

**Key Features**:
- Stockfish analyzes key positions (opening, middlegame, endgame)
- Engine data includes: evaluation scores, move classifications (blunder, mistake, brilliancy)
- Server caches results by PGN hash
- Fallback to LLM if engine fails
- Move validation to catch remaining hallucinations

**Implementation Plan**:

1. Create `lib/stockfish-client.ts` - Stockfish wrapper for client-side
2. Create test script to validate wrapper with sample games
3. Design engine analysis data types
4. Update GameAnalysis type to include engine data
5. Update story generation prompts to use engine data
6. Integrate Stockfish analysis into PGN upload flow
7. Add PGN hash caching
8. Update generate-story route to accept engine data
9. Add fallback logic
10. Add move validation
11. Test full flow with sample games
12. Run linting and typecheck

**Files Modified**:
- `ROADMAP.md` - Added Phase 6: Stockfish Integration

**Files Created**:
- `sessions/15.md` - This session file

**Definition of Done**:
- ✅ Problem identified and documented
- ✅ Phase 6 added to ROADMAP.md
- ✅ Clarification questions answered
- ✅ Integration approach decided (client-side stockfish.js)
- ✅ Implementation plan created with 13 todo items
- ✅ Testing approach planned (standalone before integration)
- ✅ Session file created
- ✅ Changes committed and pushed

**Next Steps**:
1. Create Stockfish client wrapper (phase6-1)
2. Create test script with sample games (phase6-2)
3. Review engine output data structure (phase6-3)
4. Design and implement remaining Phase 6 tasks

**Technical Notes**:
- Key positions to analyze: Opening (first 10 moves), Middlegame (every 5th + captures), Endgame (last 10 moves), Interesting positions (>50 centipawn change)
- Evaluation format: Centipawn score (e.g., +150 = 1.5 pawn advantage, mate in 3 = #3)
- Move classifications: Blunder (>200 loss), Mistake (100-200), Inaccuracy (50-99), Good move (0-49), Brilliancy (>200 gain)
- Engine depth: 15-18 plies for good speed/accuracy balance
